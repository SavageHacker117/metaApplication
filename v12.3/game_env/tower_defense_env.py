
import numpy as np
from typing import List, Tuple, Dict, Any

class TowerDefenseEnv:
    """
    Represents the core Tower Defense game environment.
    Manages the game grid, tower placements, enemy paths, and game state.
    """
    def __init__(self, grid_size: Tuple[int, int] = (10, 10), initial_cash: int = 100, initial_lives: int = 10):
        self.grid_size = grid_size
        self.grid = np.zeros(grid_size, dtype=int) # 0: empty, 1: path, 2: tower, 3: enemy spawn, 4: enemy exit
        self.cash = initial_cash
        self.lives = initial_lives
        self.towers = {}
        self.enemies = []
        self.path = []
        self.game_over = False
        self.wave_number = 0

        self._initialize_grid()

    def _initialize_grid(self):
        # Placeholder for grid initialization (e.g., setting up a default path)
        # In a real scenario, this could be generated by the LLM or loaded.
        self.grid[0, :] = 1 # Example: top row is path
        self.grid[1:, -1] = 1 # Example: rightmost column is path
        self.grid[0, 0] = 3 # Spawn point
        self.grid[-1, -1] = 4 # Exit point
        self.path = self._find_path((0,0), (self.grid_size[0]-1, self.grid_size[1]-1))

    def _find_path(self, start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:
        # Simple placeholder for pathfinding (e.g., A* or BFS would be used)
        # For now, a straight line path if possible, or a basic L-shape.
        path = []
        current_x, current_y = start
        while (current_x, current_y) != end:
            path.append((current_x, current_y))
            if current_x < end[0]:
                current_x += 1
            elif current_y < end[1]:
                current_y += 1
            elif current_x > end[0]:
                current_x -= 1
            elif current_y > end[1]:
                current_y -= 1
            else:
                break # Should not happen if path exists
        path.append(end)
        return path

    def reset(self) -> Dict[str, Any]:
        """
        Resets the environment to its initial state.
        """
        self.grid = np.zeros(self.grid_size, dtype=int)
        self.cash = 100
        self.lives = 10
        self.towers = {}
        self.enemies = []
        self.game_over = False
        self.wave_number = 0
        self._initialize_grid()
        return self.get_state()

    def get_state(self) -> Dict[str, Any]:
        """
        Returns the current state of the game environment.
        """
        return {
            "grid": self.grid.tolist(),
            "cash": self.cash,
            "lives": self.lives,
            "towers": self.towers,
            "enemies": [enemy.get_status() for enemy in self.enemies],
            "wave_number": self.wave_number,
            "game_over": self.game_over
        }

    def place_tower(self, x: int, y: int, tower_type: str) -> bool:
        """
        Attempts to place a tower at the given coordinates.
        Returns True if successful, False otherwise.
        """
        if not (0 <= x < self.grid_size[0] and 0 <= y < self.grid_size[1]):
            print(f"Invalid coordinates: ({x},{y})")
            return False
        if self.grid[x, y] != 0: # Must be an empty spot
            print(f"Cannot place tower at ({x},{y}): spot is not empty.")
            return False
        # Placeholder for cost and tower type validation
        cost = 50 # Example cost
        if self.cash < cost:
            print(f"Not enough cash to place {tower_type} tower. Needed {cost}, have {self.cash}.")
            return False

        self.grid[x, y] = 2 # Mark as tower
        self.cash -= cost
        self.towers[(x, y)] = {"type": tower_type, "level": 1, "range": 2, "damage": 10}
        print(f"Placed {tower_type} tower at ({x},{y}). Cash remaining: {self.cash}")
        return True

    def update_game_state(self) -> None:
        """
        Updates the game state for one tick (e.g., enemies move, towers attack).
        """
        # Placeholder for enemy movement, tower attacking, etc.
        # This would be a complex simulation logic.
        # For now, just a dummy update.
        if not self.game_over:
            # Simulate enemies moving and potentially reducing lives
            if self.enemies: # If there are enemies, simulate one reaching the end
                self.lives -= 1
                self.enemies.pop(0) # Remove one enemy
                print(f"An enemy reached the exit! Lives remaining: {self.lives}")

            if self.lives <= 0:
                self.game_over = True
                print("Game Over!")

    def spawn_wave(self, num_enemies: int = 5) -> None:
        """
        Spawns a new wave of enemies.
        """
        self.wave_number += 1
        print(f"Spawning Wave {self.wave_number} with {num_enemies} enemies.")
        # Placeholder for actual enemy spawning logic along the path
        for _ in range(num_enemies):
            self.enemies.append(Enemy(path=self.path))

    def step(self, action: Dict[str, Any]) -> Tuple[Dict[str, Any], float, bool, Dict[str, Any]]:
        """
        Applies an action to the environment and advances the game state.
        Actions could be 'place_tower', 'upgrade_tower', 'start_wave', etc.
        Returns (next_state, reward, done, info).
        """
        reward = 0.0
        info = {}

        action_type = action.get("type")

        if action_type == "place_tower":
            x, y = action["x"], action["y"]
            tower_type = action["tower_type"]
            if self.place_tower(x, y, tower_type):
                reward += 10.0 # Reward for successful placement
            else:
                reward -= 5.0 # Penalty for invalid placement
        elif action_type == "start_wave":
            self.spawn_wave(action.get("num_enemies", 5))
            reward += 5.0 # Reward for progressing
        else:
            print(f"Unknown action type: {action_type}")
            reward -= 1.0 # Penalty for invalid action

        self.update_game_state()

        next_state = self.get_state()
        done = self.game_over

        return next_state, reward, done, info

class Enemy:
    """
    Represents a single enemy unit in the game.
    """
    def __init__(self, path: List[Tuple[int, int]], health: int = 100, speed: int = 1):
        self.path = path
        self.health = health
        self.speed = speed
        self.current_path_index = 0
        self.position = path[0]

    def move(self) -> None:
        if self.current_path_index < len(self.path) - 1:
            self.current_path_index += self.speed
            self.position = self.path[min(self.current_path_index, len(self.path) - 1)]

    def take_damage(self, damage: int) -> None:
        self.health -= damage

    def is_alive(self) -> bool:
        return self.health > 0

    def get_status(self) -> Dict[str, Any]:
        return {"position": self.position, "health": self.health, "alive": self.is_alive()}

# Example Usage:
# if __name__ == "__main__":
#     env = TowerDefenseEnv()
#     state = env.reset()
#     print("Initial State:", state)

#     # Example actions
#     action1 = {"type": "place_tower", "x": 2, "y": 2, "tower_type": "basic"}
#     state, reward, done, info = env.step(action1)
#     print("State after placing tower:", state["grid"])
#     print("Reward:", reward)

#     action2 = {"type": "start_wave", "num_enemies": 3}
#     state, reward, done, info = env.step(action2)
#     print("State after starting wave:", state["enemies"])
#     print("Lives:", state["lives"])

#     # Simulate game progression
#     for _ in range(5):
#         if not done:
#             state, reward, done, info = env.step({"type": "no_op"}) # Simulate game tick without specific action
#             print(f"Lives: {state["lives"]}")
#             if done:
#                 print("Game Over!")
#                 break

