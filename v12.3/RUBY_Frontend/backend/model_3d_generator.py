import os
import uuid
import datetime
import json
from PIL import Image
import io
import base64

class Model3DGenerator:
    def __init__(self, models_dir="generated_models"):
        self.models_dir = models_dir
        os.makedirs(models_dir, exist_ok=True)
    
    def generate_model(self, prompt, format_type="glb", quality="medium"):
        """
        Generate a 3D model based on the prompt
        Returns a dictionary with model information
        """
        try:
            model_id = str(uuid.uuid4())
            
            # For demonstration, we'll create placeholder files
            # In a real implementation, this would integrate with actual 3D generation
            model_filename = f"{model_id}.{format_type}"
            model_path = os.path.join(self.models_dir, model_filename)
            
            # Create a more realistic 3D model file structure
            if format_type.lower() == "glb":
                # GLB is a binary format, so we'll create a minimal binary file
                self._create_glb_placeholder(model_path, prompt)
            elif format_type.lower() == "obj":
                # OBJ is text-based, create a simple cube
                self._create_obj_placeholder(model_path, prompt)
            elif format_type.lower() == "stl":
                # STL is binary, create a simple binary file
                self._create_stl_placeholder(model_path, prompt)
            else:
                # Default to GLB
                self._create_glb_placeholder(model_path, prompt)
            
            # Generate preview image
            preview_filename = f"{model_id}_preview.jpg"
            preview_path = os.path.join(self.models_dir, preview_filename)
            self._create_preview_image(preview_path, prompt)
            
            # Generate thumbnail
            thumbnail_filename = f"{model_id}_thumb.jpg"
            thumbnail_path = os.path.join(self.models_dir, thumbnail_filename)
            self._create_thumbnail(preview_path, thumbnail_path)
            
            return {
                "model_id": model_id,
                "model_path": model_path,
                "preview_path": preview_path,
                "thumbnail_path": thumbnail_path,
                "filename": model_filename,
                "format": format_type,
                "prompt": prompt,
                "created_at": datetime.datetime.now().isoformat(),
                "status": "success"
            }
            
        except Exception as e:
            return {
                "status": "error",
                "error": str(e)
            }
    
    def _create_glb_placeholder(self, file_path, prompt):
        """Create a placeholder GLB file"""
        # This is a minimal GLB file structure
        # In reality, you would use a proper 3D library like trimesh or pygltflib
        header = b'glTF' + (2).to_bytes(4, 'little') + (100).to_bytes(4, 'little')
        json_chunk = json.dumps({
            "asset": {"version": "2.0", "generator": "Manus AI v6.2"},
            "scene": 0,
            "scenes": [{"nodes": [0]}],
            "nodes": [{"mesh": 0}],
            "meshes": [{"primitives": [{"attributes": {"POSITION": 0}}]}],
            "accessors": [{"bufferView": 0, "componentType": 5126, "count": 8, "type": "VEC3"}],
            "bufferViews": [{"buffer": 0, "byteLength": 96}],
            "buffers": [{"byteLength": 96}],
            "extras": {"prompt": prompt}
        }).encode('utf-8')
        
        # Pad to 4-byte boundary
        while len(json_chunk) % 4 != 0:
            json_chunk += b' '
        
        json_header = (len(json_chunk)).to_bytes(4, 'little') + b'JSON'
        
        # Simple vertex data for a cube
        vertex_data = b'\x00' * 96  # 8 vertices * 3 components * 4 bytes
        
        with open(file_path, 'wb') as f:
            f.write(header)
            f.write(json_header)
            f.write(json_chunk)
            f.write(vertex_data)
    
    def _create_obj_placeholder(self, file_path, prompt):
        """Create a placeholder OBJ file with a simple cube"""
        obj_content = f"""# 3D Model generated by Manus AI v6.2
# Prompt: {prompt}
# Generated: {datetime.datetime.now()}

# Vertices
v -1.0 -1.0  1.0
v  1.0 -1.0  1.0
v  1.0  1.0  1.0
v -1.0  1.0  1.0
v -1.0 -1.0 -1.0
v  1.0 -1.0 -1.0
v  1.0  1.0 -1.0
v -1.0  1.0 -1.0

# Faces
f 1 2 3 4
f 5 8 7 6
f 1 5 6 2
f 2 6 7 3
f 3 7 8 4
f 5 1 4 8
"""
        with open(file_path, 'w') as f:
            f.write(obj_content)
    
    def _create_stl_placeholder(self, file_path, prompt):
        """Create a placeholder STL file"""
        # STL binary format header
        header = f"Generated by Manus AI v6.2 - {prompt[:50]}".ljust(80, '\0').encode('ascii')
        triangle_count = (12).to_bytes(4, 'little')  # 12 triangles for a cube
        
        with open(file_path, 'wb') as f:
            f.write(header)
            f.write(triangle_count)
            # Write 12 triangles (simplified cube)
            for i in range(12):
                # Normal vector (3 floats)
                f.write(b'\x00\x00\x00\x00' * 3)
                # 3 vertices (9 floats total)
                f.write(b'\x00\x00\x00\x00' * 9)
                # Attribute byte count
                f.write(b'\x00\x00')
    
    def _create_preview_image(self, file_path, prompt):
        """Create a preview image for the 3D model"""
        # Create a 400x400 preview image
        img = Image.new('RGB', (400, 400), color='#1a1a1a')
        
        # Add some visual elements to make it look like a 3D preview
        from PIL import ImageDraw, ImageFont
        draw = ImageDraw.Draw(img)
        
        # Draw a simple 3D-looking shape
        # Draw a cube in isometric view
        points = [
            (100, 150), (200, 100), (300, 150), (200, 200),  # Top face
            (100, 150), (100, 250), (200, 300), (200, 200),  # Left face
            (200, 200), (200, 300), (300, 250), (300, 150)   # Right face
        ]
        
        # Top face
        draw.polygon([(100, 150), (200, 100), (300, 150), (200, 200)], fill='#4a90e2', outline='#2171b5')
        # Left face
        draw.polygon([(100, 150), (100, 250), (200, 300), (200, 200)], fill='#357abd', outline='#2171b5')
        # Right face
        draw.polygon([(200, 200), (200, 300), (300, 250), (300, 150)], fill='#2171b5', outline='#1f5f99')
        
        # Add text
        try:
            # Try to use a default font
            font = ImageFont.load_default()
        except:
            font = None
        
        # Add prompt text (truncated)
        prompt_text = prompt[:30] + "..." if len(prompt) > 30 else prompt
        draw.text((20, 20), f"3D Model: {prompt_text}", fill='white', font=font)
        draw.text((20, 360), "Generated by Manus AI v6.2", fill='#888888', font=font)
        
        img.save(file_path, 'JPEG', quality=85)
    
    def _create_thumbnail(self, preview_path, thumbnail_path):
        """Create a thumbnail from the preview image"""
        with Image.open(preview_path) as img:
            img.thumbnail((150, 150), Image.Resampling.LANCZOS)
            img.save(thumbnail_path, 'JPEG', quality=80)
    
    def list_models(self):
        """List all generated models"""
        models = []
        for filename in os.listdir(self.models_dir):
            if not filename.endswith(('_preview.jpg', '_thumb.jpg')):
                model_id = filename.split('.')[0]
                preview_file = f"{model_id}_preview.jpg"
                thumbnail_file = f"{model_id}_thumb.jpg"
                
                model_info = {
                    "model_id": model_id,
                    "filename": filename,
                    "format": filename.split('.')[-1],
                    "download_url": f"/models/{model_id}/{filename}",
                    "preview_url": f"/models/{model_id}/{preview_file}" if os.path.exists(os.path.join(self.models_dir, preview_file)) else None,
                    "thumbnail_url": f"/models/{model_id}/{thumbnail_file}" if os.path.exists(os.path.join(self.models_dir, thumbnail_file)) else None
                }
                models.append(model_info)
        
        return sorted(models, key=lambda x: x['model_id'], reverse=True)
    
    def delete_model(self, model_id):
        """Delete a model and its associated files"""
        try:
            files_to_delete = []
            for filename in os.listdir(self.models_dir):
                if filename.startswith(model_id):
                    files_to_delete.append(os.path.join(self.models_dir, filename))
            
            for file_path in files_to_delete:
                os.remove(file_path)
            
            return {"status": "success", "deleted_files": len(files_to_delete)}
        except Exception as e:
            return {"status": "error", "error": str(e)}

